<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="theme-color" content="#3a3a44">
<title>Ramadan Clock — Three.js</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600&family=Lateef:wght@700&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;user-select:none;-webkit-user-select:none}
canvas{display:block;width:100%;height:100%}
#info{position:fixed;bottom:env(safe-area-inset-bottom,12px);left:0;right:0;text-align:center;font-family:'Inter',system-ui,sans-serif;pointer-events:none;z-index:10;padding:0 16px 12px;opacity:0;transition:opacity .4s}
#info.visible{opacity:1}
#info .hijri{font-size:14px;font-weight:500;letter-spacing:.5px}
#info .greg{font-size:11px;font-weight:300;margin-top:2px}
#info .loc{font-size:10px;font-weight:300;margin-top:4px;opacity:.5}
#dialBar{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 80px);left:0;right:0;display:flex;justify-content:center;gap:8px;opacity:0;transition:opacity .4s;z-index:10;pointer-events:none}
#dialBar.visible{opacity:1;pointer-events:auto}
.dial-dot{width:8px;height:8px;border-radius:50%;border:1.5px solid rgba(255,255,255,.3);cursor:pointer;transition:all .3s}
.dial-dot.active{border-color:rgba(255,255,255,.8);background:rgba(255,255,255,.5)}
</style>
</head>
<body>

<div id="info">
  <div class="hijri" id="hijri"></div>
  <div class="greg" id="greg"></div>
  <div class="loc" id="loc"></div>
</div>

<div id="dialBar">
  <div class="dial-dot" data-dial="tennis" style="border-color:#2e8b57"></div>
  <div class="dial-dot" data-dial="white" style="border-color:#e8e4dc"></div>
  <div class="dial-dot" data-dial="salmon" style="border-color:#c47a60"></div>
  <div class="dial-dot active" data-dial="slate" style="border-color:#6a6a74"></div>
  <div class="dial-dot" data-dial="sky" style="border-color:#5a9ac0"></div>
  <div class="dial-dot" data-dial="cream" style="border-color:#d8ccb4"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.170.0",
    "three/addons/": "https://esm.sh/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

// ══════════════════════════════════════════
// DIAL SYSTEM
// ══════════════════════════════════════════
const DIALS = {
  tennis:  {bg:'#2e8b57',lume:'#c8e860',lumeDim:'#6aaa50',hand:'#f4f0e0',handStroke:'#ffffff',shadow:'#002814',text:'#fffff0',accent:'#f0e060'},
  white:   {bg:'#e8e4dc',lume:'#1a1a1a',lumeDim:'#888888',hand:'#111111',handStroke:'#c41e3a',shadow:'#000000',text:'#1a1a1a',accent:'#c8a040'},
  salmon:  {bg:'#c47a60',lume:'#fff0e0',lumeDim:'#d4a890',hand:'#f8f4ec',handStroke:'#ffffff',shadow:'#3c140a',text:'#fff0e0',accent:'#f0d060'},
  slate:   {bg:'#3a3a44',lume:'#c0c0ca',lumeDim:'#6a6a74',hand:'#e0e0e4',handStroke:'#f0f0f4',shadow:'#000000',text:'#e0e0e4',accent:'#a0a0b0'},
  sky:     {bg:'#5a9ac0',lume:'#f0f8ff',lumeDim:'#8abcda',hand:'#f4f0e8',handStroke:'#ffffff',shadow:'#001428',text:'#f0f8ff',accent:'#f0e060'},
  cream:   {bg:'#d8ccb4',lume:'#3a3530',lumeDim:'#8a8478',hand:'#2a2520',handStroke:'#3a3530',shadow:'#000000',text:'#3a3530',accent:'#b08840'},
};
const LUME_COLORS = ['#c8e860','#e0e0e4','#60a0e0','#e0a040','#40d8d0','#d04040','#a080e0','#d4a017','#e08070','#e070a0','#60d8a0','#e0d060','#a0d0f0','#d0a030'];
const DIAL_DEFAULT_LUME = {tennis:3,white:2,salmon:4,slate:0,sky:7,cream:6};
const DIAL_NAMES = ['tennis','white','salmon','slate','sky','cream'];
const ARABIC = ['١٢','١','٢','٣','٤','٥','٦','٧','٨','٩','١٠','١١'];

let currentDial = 'slate';
let modeBlend = 0, modeTarget = 0;

// Stars (Surah Yusuf 12:4)
const STARS = [];
for (let i = 0; i < 11; i++) {
  const t = i / 10, dip = 4*t*(1-t);
  STARS.push({ x:0.08+t*0.84, y:0.03+dip*0.12, r:0.8+Math.sin(i*1.7)*0.5+0.3, speed:0.0009+i*0.00008, offset:i*0.57, bright:0.7+Math.sin(i*2.3)*0.2 });
}

// Prayer
let PD = null;
function pM(s) { if(!s)return 0; const [h,m]=s.split(':').map(Number); return h*60+m; }
function nM() { const d=new Date(); return d.getHours()*60+d.getMinutes()+d.getSeconds()/60; }

// ══════════════════════════════════════════
// RENDERER + SCENE
// ══════════════════════════════════════════
let W = window.innerWidth, H = window.innerHeight;
let R = Math.min(W, H) * 0.40;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5));
renderer.setSize(W, H);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const bloomScene = new THREE.Scene();
const cam = new THREE.OrthographicCamera(-W/2, W/2, H/2, -H/2, -200, 200);
cam.position.z = 100;

// ── Bloom pipeline ──
const rt = new THREE.WebGLRenderTarget(W, H, { type: THREE.HalfFloatType, samples: 4 });
const composer = new EffectComposer(renderer, rt);
composer.addPass(new RenderPass(scene, cam));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(W,H), 0.0, 0.4, 0.85);
composer.addPass(bloomPass);

const bloomRT = new THREE.WebGLRenderTarget(W, H, { type: THREE.HalfFloatType });
const bloomComposer = new EffectComposer(renderer, bloomRT);
bloomComposer.addPass(new RenderPass(bloomScene, cam));
const bloomPass2 = new UnrealBloomPass(new THREE.Vector2(W,H), 1.5, 0.8, 0.0);
bloomComposer.addPass(bloomPass2);

const finalPass = new ShaderPass(new THREE.ShaderMaterial({
  uniforms: { baseTexture:{value:null}, bloomTexture:{value:bloomComposer.renderTarget2.texture} },
  vertexShader: `varying vec2 vUv; void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`,
  fragmentShader: `uniform sampler2D baseTexture;uniform sampler2D bloomTexture;varying vec2 vUv;void main(){gl_FragColor=texture2D(baseTexture,vUv)+vec4(texture2D(bloomTexture,vUv).rgb,0.);}`
}), 'baseTexture');
finalPass.needsSwap = true;
composer.addPass(finalPass);

// ══════════════════════════════════════════
// HELPERS
// ══════════════════════════════════════════
const _c = new THREE.Color();
function hx(hex) { return _c.set(hex).clone(); }
function hexRGB(hex) { return {r:parseInt(hex.slice(1,3),16),g:parseInt(hex.slice(3,5),16),b:parseInt(hex.slice(5,7),16)}; }
function lerpH(a,b,t) { const ca=new THREE.Color(a), cb=new THREE.Color(b); return '#'+ca.lerp(cb,t).getHexString(); }

function getColors() {
  const day = DIALS[currentDial];
  if (modeBlend < 0.01) return day;
  const lc = LUME_COLORS[DIAL_DEFAULT_LUME[currentDial]||0];
  const night = {bg:'#0a0a0f',lume:lc,lumeDim:lc,hand:lc,handStroke:lc,shadow:'#000000',text:lc,accent:lc};
  const l = (a,b) => lerpH(a,b,modeBlend);
  return {bg:l(day.bg,night.bg),lume:l(day.lume,night.lume),lumeDim:l(day.lumeDim,night.lumeDim),hand:l(day.hand,night.hand),handStroke:l(day.handStroke,night.handStroke),shadow:l(day.shadow,night.shadow),text:l(day.text,night.text),accent:l(day.accent,night.accent)};
}

// ══════════════════════════════════════════
// MESH FACTORIES
// ══════════════════════════════════════════
function makeCircle(r, color, z) {
  const m = new THREE.Mesh(new THREE.CircleGeometry(r,128), new THREE.MeshBasicMaterial({color:hx(color)}));
  m.position.z = z||0; return m;
}
function makeRing(ir, or, color, z) {
  const m = new THREE.Mesh(new THREE.RingGeometry(ir,or,256), new THREE.MeshBasicMaterial({color:hx(color),side:THREE.DoubleSide}));
  m.position.z = z||0; return m;
}
function makePlane(w, h, color, z) {
  const m = new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({color:hx(color)}));
  m.position.z = z||0; return m;
}

// NOMOS leaf hand
function makeLeafHand(len, maxW, tailLen, color, z) {
  const s = new THREE.Shape(), hw = maxW/2;
  s.moveTo(-hw*0.6, -tailLen);
  s.quadraticCurveTo(-hw, len*0.1, -hw, len*0.3);
  s.quadraticCurveTo(-hw*0.3, len*0.75, 0, len);
  s.quadraticCurveTo(hw*0.3, len*0.75, hw, len*0.3);
  s.quadraticCurveTo(hw, len*0.1, hw*0.6, -tailLen);
  s.closePath();
  const m = new THREE.Mesh(new THREE.ShapeGeometry(s,32), new THREE.MeshBasicMaterial({color:hx(color)}));
  m.position.z = z||0; return m;
}

// Hand outline (for depth/edge feel)
function makeLeafOutline(len, maxW, tailLen, color, z) {
  const hw = maxW/2;
  const pts = [];
  const steps = 40;
  // Build outline path
  for (let i = 0; i <= steps; i++) {
    const t = i/steps;
    let x, y;
    if (t < 0.15) { // tail to base
      const lt = t/0.15;
      x = -hw*0.6 + (-hw - (-hw*0.6)) * lt;
      y = -tailLen + (len*0.1 - (-tailLen)) * lt;
    } else if (t < 0.5) { // base to tip (left side)
      const lt = (t-0.15)/0.35;
      const p0x=-hw, p0y=len*0.3, p1x=-hw*0.3, p1y=len*0.75, p2x=0, p2y=len;
      const u = lt;
      x = (1-u)*(1-u)*p0x + 2*(1-u)*u*p1x + u*u*p2x;
      y = (1-u)*(1-u)*p0y + 2*(1-u)*u*p1y + u*u*p2y;
    } else if (t < 0.85) { // tip to base (right side)
      const lt = (t-0.5)/0.35;
      const p0x=0, p0y=len, p1x=hw*0.3, p1y=len*0.75, p2x=hw, p2y=len*0.3;
      const u = lt;
      x = (1-u)*(1-u)*p0x + 2*(1-u)*u*p1x + u*u*p2x;
      y = (1-u)*(1-u)*p0y + 2*(1-u)*u*p1y + u*u*p2y;
    } else { // base to tail
      const lt = (t-0.85)/0.15;
      x = hw + (hw*0.6 - hw)*lt;
      y = len*0.1 + (-tailLen - len*0.1)*lt;
    }
    pts.push(new THREE.Vector3(x, y, 0));
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({color:hx(color), transparent:true, opacity:0.3});
  const line = new THREE.Line(geo, mat);
  line.position.z = z||0;
  return line;
}

function makeTextTex(text, font, size, color, w, h) {
  const cv = document.createElement('canvas');
  cv.width=w*2; cv.height=h*2;
  const ctx=cv.getContext('2d');
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.font = font.replace(/(\d+)px/,(_,n)=>(n*2)+'px');
  ctx.fillStyle = color;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text, cv.width/2, cv.height/2);
  const tex = new THREE.CanvasTexture(cv);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  return tex;
}
function makeText(text, font, size, color, z) {
  const w=size*Math.max(text.length,1)*1.2, h=size*1.5;
  const tex=makeTextTex(text,font,size,color,w,h);
  const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true,depthTest:false}));
  sp.scale.set(w,h,1); sp.position.z=z||0; return sp;
}

// ══════════════════════════════════════════
// DIAL TEXTURE (matte grain)
// ══════════════════════════════════════════
function createDialTexture(bgColor) {
  const S = 1024, cv = document.createElement('canvas');
  cv.width=S; cv.height=S;
  const ctx=cv.getContext('2d');
  ctx.fillStyle=bgColor;
  ctx.fillRect(0,0,S,S);
  // Fine grain
  for (let i=0;i<10000;i++) {
    ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.01)' : 'rgba(0,0,0,0.01)';
    ctx.fillRect(Math.random()*S, Math.random()*S, 1, 1);
  }
  const tex=new THREE.CanvasTexture(cv);
  tex.minFilter=THREE.LinearFilter;
  return tex;
}

// ══════════════════════════════════════════
// GLASS DOME TEXTURE
// ══════════════════════════════════════════
function createGlassTexture() {
  const S = 512, cv = document.createElement('canvas');
  cv.width=S; cv.height=S;
  const ctx=cv.getContext('2d');
  ctx.clearRect(0,0,S,S);
  const cx=S/2, cy=S/2, r=S/2;
  
  // Mask to circle
  ctx.save();
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();
  
  // Very subtle edge darkening (dome curvature)
  const edgeGrad = ctx.createRadialGradient(cx,cy,r*0.6, cx,cy,r);
  edgeGrad.addColorStop(0, 'rgba(0,0,0,0)');
  edgeGrad.addColorStop(0.85, 'rgba(0,0,0,0)');
  edgeGrad.addColorStop(1, 'rgba(0,0,0,0.08)');
  ctx.fillStyle = edgeGrad;
  ctx.fillRect(0,0,S,S);
  
  // Highlight arc (top-left light catch — the signature of domed glass)
  ctx.beginPath();
  const hlCx = cx - r*0.25, hlCy = cy - r*0.25;
  const hlGrad = ctx.createRadialGradient(hlCx, hlCy, r*0.05, hlCx, hlCy, r*0.55);
  hlGrad.addColorStop(0, 'rgba(255,255,255,0.12)');
  hlGrad.addColorStop(0.3, 'rgba(255,255,255,0.04)');
  hlGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = hlGrad;
  ctx.fillRect(0,0,S,S);
  
  // Sharp crescent highlight (like light hitting curved glass edge)
  ctx.beginPath();
  ctx.arc(cx - r*0.15, cy - r*0.35, r*0.45, -0.8, 0.3);
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth = r*0.03;
  ctx.lineCap = 'round';
  ctx.stroke();
  
  // Secondary smaller highlight
  ctx.beginPath();
  ctx.arc(cx + r*0.3, cy + r*0.35, r*0.25, 2.5, 3.5);
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = r*0.02;
  ctx.stroke();
  
  ctx.restore();
  
  const tex = new THREE.CanvasTexture(cv);
  tex.minFilter = THREE.LinearFilter;
  return tex;
}

// ══════════════════════════════════════════
// GYROSCOPE PARALLAX
// ══════════════════════════════════════════
let gyroX = 0, gyroY = 0;
let targetGyroX = 0, targetGyroY = 0;
const PARALLAX_RANGE = 12; // max px shift for deepest layer
const PARALLAX_SMOOTH = 0.08;

function initGyro() {
  if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
    // iOS 13+ — need user gesture
    const handler = () => {
      DeviceOrientationEvent.requestPermission().then(state => {
        if (state === 'granted') {
          window.addEventListener('deviceorientation', onGyro);
        }
      }).catch(()=>{});
      document.removeEventListener('click', handler);
    };
    document.addEventListener('click', handler, { once: false });
  } else {
    window.addEventListener('deviceorientation', onGyro);
  }
  
  // Mouse fallback for desktop
  window.addEventListener('mousemove', e => {
    targetGyroX = ((e.clientX / W) - 0.5) * 2; // -1 to 1
    targetGyroY = ((e.clientY / H) - 0.5) * 2;
  });
}

function onGyro(e) {
  if (e.gamma === null || e.beta === null) return;
  // gamma: left/right tilt (-90 to 90), beta: front/back (−180 to 180)
  targetGyroX = Math.max(-1, Math.min(1, (e.gamma || 0) / 30));
  targetGyroY = Math.max(-1, Math.min(1, ((e.beta || 0) - 45) / 30)); // 45° is "looking at phone"
}

function updateParallax() {
  gyroX += (targetGyroX - gyroX) * PARALLAX_SMOOTH;
  gyroY += (targetGyroY - gyroY) * PARALLAX_SMOOTH;
}

// Apply parallax shift to a group based on depth factor (0=no shift, 1=max shift)
function applyParallax(group, depth) {
  if (!group) return;
  group.position.x = gyroX * PARALLAX_RANGE * depth;
  group.position.y = -gyroY * PARALLAX_RANGE * depth;
}

initGyro();

// ══════════════════════════════════════════
// SCENE GROUPS (layered by depth for parallax)
// ══════════════════════════════════════════
const bgGroup = new THREE.Group();          // depth 0 (stationary)
const faceGroup = new THREE.Group();        // depth 0.1
const indicesGroup = new THREE.Group();     // depth 0.3
const numeralsGroup = new THREE.Group();    // depth 0.3
const arcGroup = new THREE.Group();         // depth 0.2
const shadowGroup = new THREE.Group();      // depth 0.5
const handsGroup = new THREE.Group();       // depth 0.6
const capGroup = new THREE.Group();         // depth 0.7
const qiblaGroup = new THREE.Group();       // depth 0.4
const flapGroup = new THREE.Group();        // depth 0.3
const starsGroup = new THREE.Group();       // depth 0 (sky)
const glassGroup = new THREE.Group();       // depth 0.9 (top — moves most)
const bloomGroup = new THREE.Group();

scene.add(bgGroup, faceGroup, starsGroup, indicesGroup, numeralsGroup, arcGroup, flapGroup, qiblaGroup, shadowGroup, handsGroup, capGroup, glassGroup);
bloomScene.add(bloomGroup);

// BG
const bgGeo = new THREE.PlaneGeometry(W*3,H*3);
const bgMat = new THREE.MeshBasicMaterial({color:hx('#3a3a44')});
const bgMesh = new THREE.Mesh(bgGeo, bgMat);
bgMesh.position.z = -10;
bgGroup.add(bgMesh);

// Bloom BG
const bloomBgGeo = new THREE.PlaneGeometry(W*3,H*3);
const bloomBgMesh = new THREE.Mesh(bloomBgGeo, new THREE.MeshBasicMaterial({color:0x000000}));
bloomBgMesh.position.z = -10;
bloomGroup.add(bloomBgMesh);

// ══════════════════════════════════════════
// DYNAMIC STATE
// ══════════════════════════════════════════
let dialFaceMesh = null, dialFaceTexture = null;
let glassMesh = null;
let hourMarkers = [], minuteMarkers = [], numeralSprites = [];
let bloomLumeMarkers = [], bloomHandLumes = [];
let hourHandGroup, minuteHandGroup, secondHandGroup;
let hourShadowGroup, minuteShadowGroup, secondShadowGroup;
let hourHandMesh, minHandMesh, secHandMesh, hourLumeMesh, minLumeMesh;
let capMeshes = [];
let qiblaBg = null, qiblaNeedle = null;
let flapCanvas, flapTexture, flapSprite;
let flapPrevChars = [], flapCharAnims = [];
const FLAP_DUR = 350, FLAP_STAGGER = 60;

// Second hand smooth tick with overshoot
let secAngle = 0, secTarget = 0, secVelocity = 0;
const SEC_SPRING = 0.25, SEC_DAMP = 0.65;

// ══════════════════════════════════════════
// BUILD CLOCK
// ══════════════════════════════════════════
function buildDialFace(bgColor) {
  if (dialFaceMesh) faceGroup.remove(dialFaceMesh);
  dialFaceTexture = createDialTexture(bgColor);
  const geo = new THREE.PlaneGeometry(W*3, H*3);
  dialFaceMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({map:dialFaceTexture}));
  dialFaceMesh.position.z = -5;
  faceGroup.add(dialFaceMesh);
}

function buildGlass() {
  if (glassMesh) glassGroup.remove(glassMesh);
  const glassTex = createGlassTexture();
  const geo = new THREE.PlaneGeometry(R*2.15, R*2.15);
  glassMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({map:glassTex, transparent:true, depthTest:false}));
  glassMesh.position.z = 20;
  glassGroup.add(glassMesh);
}

function buildClock() {
  [indicesGroup,numeralsGroup,handsGroup,shadowGroup,capGroup,qiblaGroup,arcGroup,bloomGroup,starsGroup,glassGroup].forEach(g=>{
    while(g.children.length) g.remove(g.children[0]);
  });
  bloomGroup.add(bloomBgMesh);
  
  hourMarkers=[]; minuteMarkers=[]; numeralSprites=[];
  bloomLumeMarkers=[]; bloomHandLumes=[];
  
  const c = getColors();
  buildDialFace(c.bg);
  buildGlass();
  
  // ── Hour markers (NOMOS applied style) ──
  for (let i=0; i<60; i++) {
    const ang = (i/60)*Math.PI*2 - Math.PI/2;
    const isHour = i%5===0;
    
    if (isHour) {
      const mH = R*0.11, mW = R*0.026;
      const outerR = R - R*0.04;
      const midR = outerR - mH/2;
      
      // Main marker
      const marker = makePlane(mW, mH, c.hand, 2);
      marker.position.x = Math.cos(ang)*midR;
      marker.position.y = Math.sin(ang)*midR;
      marker.rotation.z = ang + Math.PI/2;
      indicesGroup.add(marker);
      hourMarkers.push(marker);
      
      // Lume fill
      const lume = makePlane(mW*0.55, mH*0.7, c.lume, 2.5);
      lume.position.x = Math.cos(ang)*midR;
      lume.position.y = Math.sin(ang)*midR;
      lume.rotation.z = ang + Math.PI/2;
      indicesGroup.add(lume);
      
      // Bloom
      const bl = makePlane(mW*0.55, mH*0.7, c.lume, 2.5);
      bl.position.copy(lume.position); bl.rotation.copy(lume.rotation);
      bloomGroup.add(bl);
      bloomLumeMarkers.push({main:lume, bloom:bl});
      
      // Marker shadow (subtle, offset down-right)
      const sh = makePlane(mW*1.15, mH*1.05, '#000000', 1.5);
      sh.material.transparent=true; sh.material.opacity=0.12;
      sh.position.x = Math.cos(ang)*midR + 1.5;
      sh.position.y = Math.sin(ang)*midR - 1.5;
      sh.rotation.z = ang + Math.PI/2;
      indicesGroup.add(sh);
    } else {
      // Minute tick
      const tH = R*0.025, tW = 0.8;
      const outerR = R - R*0.04;
      const tick = makePlane(tW, tH, c.lume, 1);
      tick.material.transparent=true; tick.material.opacity=0.25;
      tick.position.x = Math.cos(ang)*(outerR - tH/2);
      tick.position.y = Math.sin(ang)*(outerR - tH/2);
      tick.rotation.z = ang + Math.PI/2;
      indicesGroup.add(tick);
      minuteMarkers.push(tick);
    }
  }
  
  // ── Arabic numerals ──
  for (let i=0; i<12; i++) {
    const ang = (i/12)*Math.PI*2 - Math.PI/2;
    const r = R - R*0.26;
    const fs = R*0.11;
    const sp = makeText(ARABIC[i], `700 ${fs}px Lateef,system-ui,sans-serif`, fs, c.text, 4);
    sp.position.x = Math.cos(ang)*r;
    sp.position.y = Math.sin(ang)*r;
    numeralsGroup.add(sp);
    numeralSprites.push(sp);
  }
  
  buildHands(c);
  
  // ── Center cap ──
  capMeshes = [];
  // Shadow
  const capSh = makeCircle(R*0.032, '#000000', 9);
  capSh.material.transparent=true; capSh.material.opacity=0.15;
  capSh.position.x=1.5; capSh.position.y=-1.5;
  capGroup.add(capSh);
  // Main
  const capMain = makeCircle(R*0.028, c.hand, 10);
  capGroup.add(capMain); capMeshes.push(capMain);
  // Lume dot
  const capDot = makeCircle(R*0.012, c.lume, 11);
  capDot.material.transparent=true; capDot.material.opacity=0.4;
  capGroup.add(capDot); capMeshes.push(capDot);
  
  buildQibla(c);
  buildFlap();
  buildStars();
}

function buildHands(c) {
  const SO = 4, SOP = 0.15; // shadow offset, opacity
  
  // ── Hour ──
  hourHandGroup = new THREE.Group(); hourHandGroup.position.z = 6;
  const hL=R*0.46, hW=R*0.048, hT=R*0.05;
  hourHandMesh = makeLeafHand(hL, hW, hT, c.hand, 0);
  hourHandGroup.add(hourHandMesh);
  // Outline edge
  hourHandGroup.add(makeLeafOutline(hL, hW*1.02, hT, c.shadow, 0.1));
  // Lume
  const hLG = new THREE.PlaneGeometry(hW*0.3, hL*0.5);
  hourLumeMesh = new THREE.Mesh(hLG, new THREE.MeshBasicMaterial({color:hx(c.lume),transparent:true,opacity:0.65}));
  hourLumeMesh.position.y = hL*0.3; hourLumeMesh.position.z=0.5;
  hourHandGroup.add(hourLumeMesh);
  handsGroup.add(hourHandGroup);
  
  hourShadowGroup = new THREE.Group(); hourShadowGroup.position.z=5.5;
  const hSh = makeLeafHand(hL, hW*1.08, hT, '#000000', 0);
  hSh.material.transparent=true; hSh.material.opacity=SOP;
  hSh.position.x=SO; hSh.position.y=-SO;
  hourShadowGroup.add(hSh);
  shadowGroup.add(hourShadowGroup);
  
  // Bloom lume
  const hBL = new THREE.Mesh(hLG.clone(), new THREE.MeshBasicMaterial({color:hx(c.lume)}));
  hBL.position.y=hL*0.3;
  const hBG = new THREE.Group(); hBG.position.z=6; hBG.add(hBL);
  bloomGroup.add(hBG);
  bloomHandLumes.push({group:hBG, parent:hourHandGroup});
  
  // ── Minute ──
  minuteHandGroup = new THREE.Group(); minuteHandGroup.position.z=7;
  const mL=R*0.66, mW=R*0.036, mT=R*0.07;
  minHandMesh = makeLeafHand(mL, mW, mT, c.hand, 0);
  minuteHandGroup.add(minHandMesh);
  minuteHandGroup.add(makeLeafOutline(mL, mW*1.02, mT, c.shadow, 0.1));
  const mLG = new THREE.PlaneGeometry(mW*0.3, mL*0.5);
  minLumeMesh = new THREE.Mesh(mLG, new THREE.MeshBasicMaterial({color:hx(c.lume),transparent:true,opacity:0.65}));
  minLumeMesh.position.y=mL*0.3; minLumeMesh.position.z=0.5;
  minuteHandGroup.add(minLumeMesh);
  handsGroup.add(minuteHandGroup);
  
  minuteShadowGroup = new THREE.Group(); minuteShadowGroup.position.z=6.5;
  const mSh = makeLeafHand(mL, mW*1.08, mT, '#000000', 0);
  mSh.material.transparent=true; mSh.material.opacity=SOP;
  mSh.position.x=SO; mSh.position.y=-SO;
  minuteShadowGroup.add(mSh);
  shadowGroup.add(minuteShadowGroup);
  
  const mBL = new THREE.Mesh(mLG.clone(), new THREE.MeshBasicMaterial({color:hx(c.lume)}));
  mBL.position.y=mL*0.3;
  const mBG = new THREE.Group(); mBG.position.z=7; mBG.add(mBL);
  bloomGroup.add(mBG);
  bloomHandLumes.push({group:mBG, parent:minuteHandGroup});
  
  // ── Second hand (thin needle + circle counterweight) ──
  secondHandGroup = new THREE.Group(); secondHandGroup.position.z=8;
  const sL=R*0.74, sT=R*0.16;
  const ss = new THREE.Shape();
  ss.moveTo(-0.4, -sT);
  ss.lineTo(-0.25, sL);
  ss.lineTo(0.25, sL);
  ss.lineTo(0.4, -sT);
  ss.closePath();
  secHandMesh = new THREE.Mesh(new THREE.ShapeGeometry(ss), new THREE.MeshBasicMaterial({color:hx(c.handStroke)}));
  secondHandGroup.add(secHandMesh);
  // Counterweight circle
  const cwt = makeCircle(R*0.014, c.handStroke, 0);
  cwt.position.y = -sT*0.55;
  secondHandGroup.add(cwt);
  // Tip circle (tiny dot at end for refinement)
  const tip = makeCircle(1.2, c.handStroke, 0);
  tip.position.y = sL;
  secondHandGroup.add(tip);
  handsGroup.add(secondHandGroup);
  
  secondShadowGroup = new THREE.Group(); secondShadowGroup.position.z=7.5;
  const sSh = new THREE.Mesh(new THREE.ShapeGeometry(ss.clone()), new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:SOP*0.6}));
  sSh.position.x=SO*0.6; sSh.position.y=-SO*0.6;
  secondShadowGroup.add(sSh);
  shadowGroup.add(secondShadowGroup);
}

function buildQibla(c) {
  while(qiblaGroup.children.length) qiblaGroup.remove(qiblaGroup.children[0]);
  const outerR=R-R*0.04, mH=R*0.11, midR=outerR-mH/2, qr=R*0.09;
  
  qiblaBg = makeCircle(qr, c.hand, 4);
  qiblaBg.position.y = midR;
  qiblaGroup.add(qiblaBg);
  
  // Shadow under qibla
  const qSh = makeCircle(qr*1.05, '#000000', 3.5);
  qSh.material.transparent=true; qSh.material.opacity=0.1;
  qSh.position.y=midR; qSh.position.x=1.5; qSh.position.y=midR-1.5;
  qiblaGroup.add(qSh);
  
  const border = makeRing(qr-0.5, qr, c.shadow, 5);
  border.material.transparent=true; border.material.opacity=0.2;
  border.position.y = midR;
  qiblaGroup.add(border);
  
  const nL=qr*0.8, td=nL*0.55, tl=nL*0.45, hb=nL*0.32;
  const ns = new THREE.Shape();
  ns.moveTo(0,td); ns.lineTo(hb,-tl); ns.lineTo(-hb,-tl); ns.closePath();
  qiblaNeedle = new THREE.Mesh(new THREE.ShapeGeometry(ns), new THREE.MeshBasicMaterial({color:hx(c.bg)}));
  qiblaNeedle.position.y=midR; qiblaNeedle.position.z=5;
  qiblaGroup.add(qiblaNeedle);
}

function buildFlap() {
  const cw=512, ch=192;
  flapCanvas = document.createElement('canvas');
  flapCanvas.width=cw; flapCanvas.height=ch;
  flapTexture = new THREE.CanvasTexture(flapCanvas);
  flapTexture.minFilter = THREE.LinearFilter;
  
  const geo = new THREE.PlaneGeometry(R*0.6, R*0.22);
  flapSprite = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({map:flapTexture,transparent:true,depthTest:false}));
  flapSprite.position.y = -R*0.36;
  flapSprite.position.z = 9;
  flapGroup.add(flapSprite);
  
  const bf = new THREE.Mesh(geo.clone(), new THREE.MeshBasicMaterial({map:flapTexture,transparent:true,depthTest:false}));
  bf.position.copy(flapSprite.position);
  bloomGroup.add(bf);
}

function buildStars() {
  while(starsGroup.children.length) starsGroup.remove(starsGroup.children[0]);
  STARS.forEach(s => {
    const m = new THREE.Mesh(new THREE.CircleGeometry(s.r*1.5,16), new THREE.MeshBasicMaterial({color:0xfffff0,transparent:true,opacity:0}));
    m.position.x=(s.x-0.5)*W; m.position.y=(0.5-s.y)*H; m.position.z=-5;
    m.userData=s; starsGroup.add(m);
  });
}

// ══════════════════════════════════════════
// UPDATE
// ══════════════════════════════════════════
let lastDial = '';
function updateColors() {
  const c = getColors();
  bgMat.color = hx(c.bg);
  
  if (currentDial !== lastDial) {
    buildDialFace(c.bg);
    lastDial = currentDial;
  }
  
  hourMarkers.forEach(m => m.material.color = hx(c.hand));
  bloomLumeMarkers.forEach(({main,bloom}) => { main.material.color=hx(c.lume); bloom.material.color=hx(c.lume); });
  minuteMarkers.forEach(m => m.material.color = hx(c.lume));
  
  if(hourHandMesh) hourHandMesh.material.color=hx(c.hand);
  if(hourLumeMesh) hourLumeMesh.material.color=hx(c.lume);
  if(minHandMesh) minHandMesh.material.color=hx(c.hand);
  if(minLumeMesh) minLumeMesh.material.color=hx(c.lume);
  if(secHandMesh) secHandMesh.material.color=hx(c.handStroke);
  
  if(capMeshes[0]) capMeshes[0].material.color=hx(c.hand);
  if(capMeshes[1]) capMeshes[1].material.color=hx(c.lume);
  if(qiblaBg) qiblaBg.material.color=hx(c.hand);
  if(qiblaNeedle) qiblaNeedle.material.color=hx(c.bg);
  
  bloomPass.strength = 0.12 + modeBlend * 0.8;
  bloomPass2.strength = modeBlend * 1.5;
  
  starsGroup.children.forEach(m => {
    const s=m.userData; if(!s)return;
    m.material.opacity = modeBlend * s.bright * (Math.sin(Date.now()*s.speed+s.offset)*0.3+0.7) * 0.7;
  });
  
  document.querySelector('meta[name="theme-color"]').content = c.bg;
  return c;
}

function updateHands() {
  const now = new Date();
  const h=now.getHours()%12, m=now.getMinutes(), s=now.getSeconds(), ms=now.getMilliseconds();
  const sec = s + ms/1000;
  const min = m + sec/60;
  const hour = h + min/60;
  
  const hourAng = -(hour/12)*Math.PI*2;
  const minAng = -(min/60)*Math.PI*2;
  
  // Second hand: smooth tick with spring overshoot
  const rawSecAng = -(sec/60)*Math.PI*2;
  // Detect tick boundary
  const targetSec = -(Math.floor(sec)/60)*Math.PI*2;
  if (Math.abs(targetSec - secTarget) > 0.01) {
    secTarget = targetSec;
    secVelocity = -0.15; // kick
  }
  const diff = secTarget - secAngle;
  secVelocity += diff * SEC_SPRING;
  secVelocity *= SEC_DAMP;
  secAngle += secVelocity;
  
  if(hourHandGroup) hourHandGroup.rotation.z = hourAng;
  if(minuteHandGroup) minuteHandGroup.rotation.z = minAng;
  if(secondHandGroup) secondHandGroup.rotation.z = secAngle;
  
  if(hourShadowGroup) hourShadowGroup.rotation.z = hourAng;
  if(minuteShadowGroup) minuteShadowGroup.rotation.z = minAng;
  if(secondShadowGroup) secondShadowGroup.rotation.z = secAngle;
  
  bloomHandLumes.forEach(({group,parent}) => { group.rotation.z=parent.rotation.z; });
}

function updateFlap(c) {
  if(!flapCanvas) return;
  const ctx=flapCanvas.getContext('2d');
  const cw=flapCanvas.width, ch=flapCanvas.height;
  ctx.clearRect(0,0,cw,ch);
  
  const now=new Date(), hr=now.getHours(), mn=now.getMinutes();
  const nowMin=hr*60+mn+now.getSeconds()/60;
  let label='UNTIL MAGHRIB', mins=0;
  
  if(PD) {
    const fajr=pM(PD.Fajr), mag=pM(PD.Maghrib);
    if(nowMin>=fajr&&nowMin<mag){mins=mag-nowMin;label='UNTIL IFTAR';}
    else if(nowMin<fajr){mins=fajr-nowMin;label='UNTIL FAJR';}
    else{mins=0;label='IFTAR';}
  } else { mins=Math.max(0,(18*60+15)-nowMin); }
  
  const hh=Math.floor(mins/60), mm=Math.floor(mins%60);
  const chars=[String(Math.floor(hh/10)),String(hh%10),':',String(Math.floor(mm/10)),String(mm%10)];
  
  const nowMs=performance.now();
  while(flapPrevChars.length<chars.length) flapPrevChars.push('');
  while(flapCharAnims.length<chars.length) flapCharAnims.push({start:0,prev:''});
  for(let i=0;i<chars.length;i++){
    if(chars[i]!==flapPrevChars[i]) flapCharAnims[i]={start:nowMs+i*FLAP_STAGGER,prev:flapPrevChars[i]||chars[i]};
  }
  flapPrevChars=chars.slice();
  
  const digitW=cw*0.17, colonW=cw*0.06, cellH=ch*0.65;
  const charWidths=chars.map(c=>c===':'?colonW:digitW);
  const totalW=charWidths.reduce((a,w)=>a+w,0)+(chars.length-1)*4;
  let startX=(cw-totalW)/2;
  const cellY=ch*0.15, fontSize=cellH*0.7, lumeCol=c.lume;
  
  let curX=startX;
  for(let i=0;i<chars.length;i++){
    const ch2=chars[i], charW=charWidths[i], cellCx=curX+charW/2;
    const anim=flapCharAnims[i], elapsed=nowMs-(anim.start||0), t=Math.min(Math.max(elapsed/FLAP_DUR,0),1);
    
    if(ch2===':'){
      ctx.fillStyle=lumeCol; ctx.globalAlpha=0.35;
      ctx.beginPath();ctx.arc(cellCx,cellY+cellH*0.3,2.5,0,Math.PI*2);ctx.fill();
      ctx.beginPath();ctx.arc(cellCx,cellY+cellH*0.7,2.5,0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=1; curX+=charW+4; continue;
    }
    
    ctx.fillStyle='rgba(0,0,0,0.25)';
    rr(ctx,curX,cellY,charW,cellH,3); ctx.fill();
    ctx.fillStyle='rgba(0,0,0,0.35)';
    ctx.fillRect(curX,cellY+cellH/2-0.5,charW,1);
    
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font=`500 ${fontSize}px Inter,system-ui,sans-serif`;
    ctx.fillStyle=lumeCol; ctx.globalAlpha=0.85;
    
    if(t<1&&anim.prev){
      const e2=t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
      ctx.save();ctx.beginPath();ctx.rect(curX,cellY+cellH/2,charW,cellH/2);ctx.clip();
      ctx.fillText(ch2,cellCx,cellY+cellH/2);ctx.restore();
      ctx.save();ctx.beginPath();ctx.rect(curX,cellY,charW,cellH/2);ctx.clip();
      ctx.fillText(e2<0.5?anim.prev:ch2,cellCx,cellY+cellH/2);ctx.restore();
    } else { ctx.fillText(ch2,cellCx,cellY+cellH/2); }
    ctx.globalAlpha=1; curX+=charW+4;
  }
  
  if(label){
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font=`500 ${ch*0.1}px Inter,system-ui,sans-serif`;
    ctx.fillStyle=lumeCol; ctx.globalAlpha=0.5;
    ctx.fillText(label,cw/2,cellY+cellH+ch*0.12);
    ctx.globalAlpha=1;
  }
  flapTexture.needsUpdate=true;
}

function rr(ctx,x,y,w,h,r){
  ctx.beginPath();ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);ctx.closePath();
}

function updateFastingArc(c) {
  while(arcGroup.children.length) arcGroup.remove(arcGroup.children[0]);
  if(!PD) return;
  const fajr=pM(PD.Fajr), mag=pM(PD.Maghrib), now=nM();
  const startAng=((fajr%720)/720)*Math.PI*2+Math.PI/2;
  const sweepAng=((mag-fajr)/720)*Math.PI*2;
  const endAng=startAng+sweepAng;
  const arcR=R+R*0.1;
  const isLight=currentDial==='white'||currentDial==='cream';
  
  const tc=new THREE.EllipseCurve(0,0,arcR,arcR,startAng,endAng,false,0);
  const track=new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(tc.getPoints(128)),
    new THREE.LineBasicMaterial({color:isLight?0x000000:0xffffff,transparent:true,opacity:isLight?0.15:0.25})
  );
  track.position.z=1; arcGroup.add(track);
  
  if(now>=fajr&&now<=mag){
    const nowAng=startAng+((now-fajr)/720)*Math.PI*2;
    const pc=new THREE.EllipseCurve(0,0,arcR,arcR,startAng,nowAng,false,0);
    const prog=new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(pc.getPoints(128)),
      new THREE.LineBasicMaterial({color:isLight?0x000000:0xffffff,transparent:true,opacity:isLight?0.55:0.75})
    );
    prog.position.z=1; arcGroup.add(prog);
    
    const tipM=makeCircle(3.5,'#e53e3e',2);
    tipM.position.x=Math.cos(nowAng)*arcR; tipM.position.y=Math.sin(nowAng)*arcR;
    arcGroup.add(tipM);
  }
}

// ══════════════════════════════════════════
// PRAYER TIMES
// ══════════════════════════════════════════
async function fetchPrayer(){
  try{
    const r=await fetch('https://api.aladhan.com/v1/timings/'+Math.floor(Date.now()/1000));
    const j=await r.json();
    if(j.code===200){PD=j.data.timings;updateInfoPanel();}
  }catch(e){console.warn('Prayer fetch failed',e);}
}
fetchPrayer();

function updateInfoPanel(){
  if(!PD) return;
  const c=getColors();
  document.getElementById('hijri').textContent=`Fajr ${PD.Fajr} · Maghrib ${PD.Maghrib}`;
  document.getElementById('hijri').style.color=c.text;
  document.getElementById('greg').textContent=new Date().toLocaleDateString('en-US',{weekday:'long',year:'numeric',month:'long',day:'numeric'});
  document.getElementById('greg').style.color=c.text;
}

// ══════════════════════════════════════════
// INTERACTIONS
// ══════════════════════════════════════════
let infoVisible=false, infoTimer=null;
function showInfo(){
  document.getElementById('info').classList.add('visible');
  document.getElementById('dialBar').classList.add('visible');
  infoVisible=true; clearTimeout(infoTimer);
  infoTimer=setTimeout(()=>{
    document.getElementById('info').classList.remove('visible');
    document.getElementById('dialBar').classList.remove('visible');
    infoVisible=false;
  },4000);
}

renderer.domElement.addEventListener('click', showInfo);
renderer.domElement.addEventListener('dblclick', ()=>{ modeTarget=modeTarget>0.5?0:1; });

let touchStartX=0;
renderer.domElement.addEventListener('touchstart',e=>{touchStartX=e.touches[0].clientX;});
renderer.domElement.addEventListener('touchend',e=>{
  const dx=e.changedTouches[0].clientX-touchStartX;
  if(Math.abs(dx)>50){
    const idx=DIAL_NAMES.indexOf(currentDial);
    currentDial=DIAL_NAMES[dx>0?(idx-1+DIAL_NAMES.length)%DIAL_NAMES.length:(idx+1)%DIAL_NAMES.length];
    rebuildNumerals(); updateDialDots();
  }
});

document.querySelectorAll('.dial-dot').forEach(d=>{
  d.addEventListener('click',e=>{
    e.stopPropagation();
    currentDial=d.dataset.dial;
    rebuildNumerals(); updateDialDots();
  });
});

function updateDialDots(){
  document.querySelectorAll('.dial-dot').forEach(d=>d.classList.toggle('active',d.dataset.dial===currentDial));
}

function rebuildNumerals(){
  while(numeralsGroup.children.length) numeralsGroup.remove(numeralsGroup.children[0]);
  numeralSprites=[];
  const c=getColors();
  for(let i=0;i<12;i++){
    const ang=(i/12)*Math.PI*2-Math.PI/2;
    const r=R-R*0.26, fs=R*0.11;
    const sp=makeText(ARABIC[i],`700 ${fs}px Lateef,system-ui,sans-serif`,fs,c.text,4);
    sp.position.x=Math.cos(ang)*r; sp.position.y=Math.sin(ang)*r;
    numeralsGroup.add(sp); numeralSprites.push(sp);
  }
}

// ══════════════════════════════════════════
// RESIZE
// ══════════════════════════════════════════
function onResize(){
  W=window.innerWidth; H=window.innerHeight;
  R=Math.min(W,H)*0.40;
  renderer.setSize(W,H);
  cam.left=-W/2;cam.right=W/2;cam.top=H/2;cam.bottom=-H/2;
  cam.updateProjectionMatrix();
  composer.setSize(W,H); bloomComposer.setSize(W,H);
  bloomPass.resolution.set(W,H); bloomPass2.resolution.set(W,H);
  bgMesh.scale.set(W*3/bgGeo.parameters.width, H*3/bgGeo.parameters.height,1);
  bloomBgMesh.scale.set(W*3/bloomBgGeo.parameters.width, H*3/bloomBgGeo.parameters.height,1);
  buildClock();
}
window.addEventListener('resize', onResize);

// ══════════════════════════════════════════
// RENDER LOOP
// ══════════════════════════════════════════
function animate() {
  requestAnimationFrame(animate);
  
  // Night mode blend
  if(Math.abs(modeBlend-modeTarget)>0.001) modeBlend+=(modeTarget-modeBlend)*0.04;
  else modeBlend=modeTarget;
  
  // Parallax
  updateParallax();
  applyParallax(faceGroup, 0.05);
  applyParallax(indicesGroup, 0.25);
  applyParallax(numeralsGroup, 0.25);
  applyParallax(arcGroup, 0.15);
  applyParallax(flapGroup, 0.3);
  applyParallax(qiblaGroup, 0.35);
  applyParallax(shadowGroup, 0.45);
  applyParallax(handsGroup, 0.55);
  applyParallax(capGroup, 0.6);
  applyParallax(glassGroup, 0.85);
  
  const c = updateColors();
  updateHands();
  updateFlap(c);
  updateFastingArc(c);
  
  renderer.autoClear=false;
  renderer.clear();
  composer.render();
}

buildClock();
animate();
showInfo();

</script>
</body>
</html>
