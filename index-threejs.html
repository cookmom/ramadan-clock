<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="theme-color" content="#3a3a44">
<title>Ramadan Clock — Three.js</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600&family=Lateef:wght@700&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;user-select:none;-webkit-user-select:none}
canvas{display:block;width:100%;height:100%}
#info{position:fixed;bottom:env(safe-area-inset-bottom,12px);left:0;right:0;text-align:center;font-family:'Inter',system-ui,sans-serif;pointer-events:none;z-index:10;padding:0 16px 12px;opacity:0;transition:opacity .4s}
#info.visible{opacity:1}
#info .hijri{font-size:14px;font-weight:500;letter-spacing:.5px}
#info .greg{font-size:11px;font-weight:300;margin-top:2px}
#info .loc{font-size:10px;font-weight:300;margin-top:4px;opacity:.5}
#dialBar{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 80px);left:0;right:0;display:flex;justify-content:center;gap:8px;opacity:0;transition:opacity .4s;z-index:10;pointer-events:none}
#dialBar.visible{opacity:1;pointer-events:auto}
.dial-dot{width:8px;height:8px;border-radius:50%;border:1.5px solid rgba(255,255,255,.3);cursor:pointer;transition:all .3s}
.dial-dot.active{border-color:rgba(255,255,255,.8);background:rgba(255,255,255,.5)}
</style>
</head>
<body>

<div id="info">
  <div class="hijri" id="hijri"></div>
  <div class="greg" id="greg"></div>
  <div class="loc" id="loc"></div>
</div>

<div id="dialBar">
  <div class="dial-dot" data-dial="tennis" style="border-color:#2e8b57"></div>
  <div class="dial-dot" data-dial="white" style="border-color:#e8e4dc"></div>
  <div class="dial-dot" data-dial="salmon" style="border-color:#c47a60"></div>
  <div class="dial-dot active" data-dial="slate" style="border-color:#6a6a74"></div>
  <div class="dial-dot" data-dial="sky" style="border-color:#5a9ac0"></div>
  <div class="dial-dot" data-dial="cream" style="border-color:#d8ccb4"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.170.0",
    "three/addons/": "https://esm.sh/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

// ── Dial Color Systems ──
const DIALS = {
  tennis:  {bg:'#2e8b57',lume:'#c8e860',lumeDim:'#6aaa50',hand:'#f4f0e0',handStroke:'#ffffff',shadow:'#002814',minNum:'#c8e860',text:'#fffff0',accent:'#f0e060'},
  white:   {bg:'#e8e4dc',lume:'#1a1a1a',lumeDim:'#888888',hand:'#111111',handStroke:'#222222',shadow:'#000000',minNum:'#000000',text:'#000000',accent:'#c8a040'},
  salmon:  {bg:'#c47a60',lume:'#fff0e0',lumeDim:'#d4a890',hand:'#f8f4ec',handStroke:'#ffffff',shadow:'#3c140a',minNum:'#fff0e0',text:'#fff0e0',accent:'#f0d060'},
  slate:   {bg:'#3a3a44',lume:'#c0c0ca',lumeDim:'#6a6a74',hand:'#e0e0e4',handStroke:'#f0f0f4',shadow:'#000000',minNum:'#c0c0ca',text:'#e0e0e4',accent:'#a0a0b0'},
  sky:     {bg:'#5a9ac0',lume:'#f0f8ff',lumeDim:'#8abcda',hand:'#f4f0e8',handStroke:'#ffffff',shadow:'#001428',minNum:'#f0f8ff',text:'#f0f8ff',accent:'#f0e060'},
  cream:   {bg:'#d8ccb4',lume:'#3a3530',lumeDim:'#8a8478',hand:'#2a2520',handStroke:'#3a3530',shadow:'#000000',minNum:'#3a3530',text:'#3a3530',accent:'#b08840'},
};

const LUME_COLORS = [
  '#c8e860','#e0e0e4','#60a0e0','#e0a040','#40d8d0',
  '#d04040','#a080e0','#d4a017','#e08070','#e070a0',
  '#60d8a0','#e0d060','#a0d0f0','#d0a030'
];
const DIAL_DEFAULT_LUME = {tennis:3,white:2,salmon:4,slate:0,sky:7,cream:6};
const DIAL_NAMES = ['tennis','white','salmon','slate','sky','cream'];

let currentDial = 'slate';
let modeBlend = 0;
let modeTarget = 0;

// ── Arabic numerals ──
const ARABIC = ['١٢','١','٢','٣','٤','٥','٦','٧','٨','٩','١٠','١١'];

// ── Stars (Surah Yusuf 12:4) ──
const STARS = [];
for (let i = 0; i < 11; i++) {
  const t = i / 10;
  const dip = 4 * t * (1 - t);
  STARS.push({ x: 0.08 + t * 0.84, y: 0.03 + dip * 0.12, r: 0.8 + Math.sin(i * 1.7) * 0.5 + 0.3, speed: 0.0009 + i * 0.00008, offset: i * 0.57, bright: 0.7 + Math.sin(i * 2.3) * 0.2 });
}

// ── Prayer data ──
let PD = null;
const PN = ['Fajr','Sunrise','Dhuhr','Asr','Maghrib','Isha'];
function pM(s) { if (!s) return 0; const [h, m] = s.split(':').map(Number); return h * 60 + m; }
function nM() { const d = new Date(); return d.getHours() * 60 + d.getMinutes() + d.getSeconds() / 60; }

// ── Three.js Setup ──
let W = window.innerWidth, H = window.innerHeight;
let R = Math.min(W, H) * 0.42;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(W, H);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const bloomScene = new THREE.Scene();

const cam = new THREE.OrthographicCamera(-W/2, W/2, H/2, -H/2, -100, 100);
cam.position.z = 100;

// ── Selective Bloom ──
const renderTarget = new THREE.WebGLRenderTarget(W, H, { type: THREE.HalfFloatType, format: THREE.RGBAFormat, samples: 4 });
const composer = new EffectComposer(renderer, renderTarget);
composer.addPass(new RenderPass(scene, cam));

const bloomPass = new UnrealBloomPass(new THREE.Vector2(W, H), 0.0, 0.4, 0.85);
composer.addPass(bloomPass);

const bloomComposer = new EffectComposer(renderer, renderTarget.clone());
bloomComposer.addPass(new RenderPass(bloomScene, cam));
const bloomPass2 = new UnrealBloomPass(new THREE.Vector2(W, H), 1.5, 0.8, 0.0);
bloomComposer.addPass(bloomPass2);

// Final compositing
const finalShader = {
  uniforms: { baseTexture: { value: null }, bloomTexture: { value: null } },
  vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
  fragmentShader: `uniform sampler2D baseTexture; uniform sampler2D bloomTexture; varying vec2 vUv; void main() { gl_FragColor = texture2D(baseTexture, vUv) + vec4(texture2D(bloomTexture, vUv).rgb, 0.0); }`
};
const finalPass = new ShaderPass(new THREE.ShaderMaterial(finalShader), 'baseTexture');
finalPass.uniforms.bloomTexture.value = bloomComposer.renderTarget2.texture;
finalPass.needsSwap = true;
composer.addPass(finalPass);

// ── Helpers ──
function hexToVec3(hex) {
  const c = new THREE.Color(hex);
  return c;
}

function hexToRGB(hex) {
  return { r: parseInt(hex.slice(1,3),16), g: parseInt(hex.slice(3,5),16), b: parseInt(hex.slice(5,7),16) };
}

function lerpHex(a, b, t) {
  const ca = new THREE.Color(a), cb = new THREE.Color(b);
  return '#' + ca.lerp(cb, t).getHexString();
}

function getColors() {
  const day = DIALS[currentDial];
  if (modeBlend < 0.01) return day;
  const effectiveLume = DIAL_DEFAULT_LUME[currentDial] || 0;
  const lc = LUME_COLORS[effectiveLume];
  const night = { bg: '#0a0a0f', lume: lc, lumeDim: lc, hand: lc, handStroke: lc, shadow: '#000000', minNum: lc, text: lc, accent: lc };
  const lerp = (a, b) => lerpHex(a, b, modeBlend);
  return {
    bg: lerp(day.bg, night.bg), lume: lerp(day.lume, night.lume), lumeDim: lerp(day.lumeDim, night.lumeDim),
    hand: lerp(day.hand, night.hand), handStroke: lerp(day.handStroke, night.handStroke),
    shadow: lerp(day.shadow, night.shadow), minNum: lerp(day.minNum, night.minNum),
    text: lerp(day.text, night.text), accent: lerp(day.accent, night.accent)
  };
}

// ── Mesh helpers ──
function makeCircle(radius, color, z = 0) {
  const geo = new THREE.CircleGeometry(radius, 128);
  const mat = new THREE.MeshBasicMaterial({ color: hexToVec3(color) });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.z = z;
  return mesh;
}

function makeRing(innerR, outerR, color, z = 0) {
  const geo = new THREE.RingGeometry(innerR, outerR, 256);
  const mat = new THREE.MeshBasicMaterial({ color: hexToVec3(color), side: THREE.DoubleSide });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.z = z;
  return mesh;
}

// NOMOS-style flat applied marker (thin rectangle, flush with dial)
function makeAppliedMarker(width, height, color, z = 0) {
  const geo = new THREE.PlaneGeometry(width, height);
  const mat = new THREE.MeshBasicMaterial({ color: hexToVec3(color) });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.z = z;
  return mesh;
}

// Leaf/dauphine hand shape (NOMOS-style — wider base, tapers to fine point)
function makeLeafHand(length, maxWidth, tailLen, color, z = 0) {
  const shape = new THREE.Shape();
  const hw = maxWidth / 2;
  // Tail
  shape.moveTo(-hw * 0.6, -tailLen);
  // Widen to max at ~30% up
  shape.quadraticCurveTo(-hw, length * 0.1, -hw, length * 0.3);
  // Taper to point
  shape.quadraticCurveTo(-hw * 0.3, length * 0.7, 0, length);
  shape.quadraticCurveTo(hw * 0.3, length * 0.7, hw, length * 0.3);
  shape.quadraticCurveTo(hw, length * 0.1, hw * 0.6, -tailLen);
  shape.closePath();
  const geo = new THREE.ShapeGeometry(shape, 32);
  const mat = new THREE.MeshBasicMaterial({ color: hexToVec3(color) });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.z = z;
  return mesh;
}

function createTextTexture(text, font, size, color, width, height) {
  const canvas = document.createElement('canvas');
  canvas.width = width * 2;
  canvas.height = height * 2;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.font = font.replace(/(\d+)px/, (_, n) => (n * 2) + 'px');
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);
  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  return tex;
}

function makeTextSprite(text, font, size, color, z = 0) {
  const w = size * Math.max(text.length, 1) * 1.2;
  const h = size * 1.5;
  const tex = createTextTexture(text, font, size, color, w, h);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(w, h, 1);
  sprite.position.z = z;
  return sprite;
}

// ── Sunburst dial texture ──
function createDialTexture(bgColor) {
  const size = 1024;
  const cv = document.createElement('canvas');
  cv.width = size; cv.height = size;
  const ctx = cv.getContext('2d');
  const cx = size / 2, cy = size / 2, r = size / 2;
  
  // Base color fill
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, size, size);
  
  // Sunburst gradient — slightly lighter at edges (like NOMOS)
  const grad = ctx.createRadialGradient(cx, cy, r * 0.1, cx, cy, r);
  const rgb = hexToRGB(bgColor);
  // Darken center slightly, lighten edges
  grad.addColorStop(0, `rgba(0,0,0,0.06)`);
  grad.addColorStop(0.5, `rgba(0,0,0,0.02)`);
  grad.addColorStop(0.85, `rgba(255,255,255,0.03)`);
  grad.addColorStop(1, `rgba(255,255,255,0.06)`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, size, size);
  
  // Subtle stipple noise (surface texture)
  for (let i = 0; i < 4000; i++) {
    const x = Math.random() * size, y = Math.random() * size;
    ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.008)' : 'rgba(0,0,0,0.008)';
    ctx.fillRect(x, y, 1, 1);
  }
  
  // Radial brushed lines (sunburst effect — very subtle)
  ctx.save();
  ctx.translate(cx, cy);
  for (let a = 0; a < 360; a += 0.5) {
    const rad = a * Math.PI / 180;
    ctx.strokeStyle = `rgba(${Math.random() > 0.5 ? '255,255,255' : '0,0,0'},${0.003 + Math.random() * 0.004})`;
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(Math.cos(rad) * r * 0.05, Math.sin(rad) * r * 0.05);
    ctx.lineTo(Math.cos(rad) * r, Math.sin(rad) * r);
    ctx.stroke();
  }
  ctx.restore();
  
  const tex = new THREE.CanvasTexture(cv);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  return tex;
}

// ── Scene Groups ──
const bgGroup = new THREE.Group();
const faceGroup = new THREE.Group();
const indicesGroup = new THREE.Group();
const numeralsGroup = new THREE.Group();
const arcGroup = new THREE.Group();
const shadowGroup = new THREE.Group();    // hand shadows
const handsGroup = new THREE.Group();
const capGroup = new THREE.Group();
const qiblaGroup = new THREE.Group();
const flapGroup = new THREE.Group();
const starsGroup = new THREE.Group();
const bloomGroup = new THREE.Group();

scene.add(bgGroup, faceGroup, indicesGroup, numeralsGroup, arcGroup, shadowGroup, handsGroup, capGroup, qiblaGroup, flapGroup, starsGroup);
bloomScene.add(bloomGroup);

// Background
const bgGeo = new THREE.PlaneGeometry(W * 2, H * 2);
const bgMat = new THREE.MeshBasicMaterial({ color: hexToVec3('#3a3a44') });
const bgMesh = new THREE.Mesh(bgGeo, bgMat);
bgMesh.position.z = -10;
bgGroup.add(bgMesh);

// Bloom bg
const bloomBgGeo = new THREE.PlaneGeometry(W * 2, H * 2);
const bloomBgMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
const bloomBgMesh = new THREE.Mesh(bloomBgGeo, bloomBgMat);
bloomBgMesh.position.z = -10;
bloomGroup.add(bloomBgMesh);

// Dial face mesh (sunburst textured circle)
let dialFaceMesh = null;
let dialFaceTexture = null;

function buildDialFace(bgColor) {
  if (dialFaceMesh) faceGroup.remove(dialFaceMesh);
  dialFaceTexture = createDialTexture(bgColor);
  // Full viewport plane — no circle edge
  const geo = new THREE.PlaneGeometry(W * 2, H * 2);
  const mat = new THREE.MeshBasicMaterial({ map: dialFaceTexture });
  dialFaceMesh = new THREE.Mesh(geo, mat);
  dialFaceMesh.position.z = -5;
  faceGroup.add(dialFaceMesh);
}

// ── Dynamic elements ──
let hourMarkers = [];
let minuteMarkers = [];
let numeralSprites = [];
let hourHandGroup, minuteHandGroup, secondHandGroup;
let hourShadowGroup, minuteShadowGroup, secondShadowGroup;
let hourHandMesh, minHandMesh, secHandMesh;
let hourLumeMesh, minLumeMesh;
let capMeshes = [];
let qiblaBg = null, qiblaNeedle = null;
let bloomLumeMarkers = [];
let bloomHandLumes = [];
let flapCanvas, flapTexture, flapSprite;

let flapPrevChars = [], flapCharAnims = [];
const FLAP_DUR = 350, FLAP_STAGGER = 60;

// ── Build clock ──
function buildClock() {
  [indicesGroup, numeralsGroup, handsGroup, shadowGroup, capGroup, qiblaGroup, arcGroup, bloomGroup, starsGroup].forEach(g => {
    while (g.children.length) g.remove(g.children[0]);
  });
  bloomGroup.add(bloomBgMesh);
  
  hourMarkers = [];
  minuteMarkers = [];
  numeralSprites = [];
  bloomLumeMarkers = [];
  bloomHandLumes = [];
  
  const c = getColors();
  
  // Sunburst dial face
  buildDialFace(c.bg);
  
  // ── NOMOS-style flat applied markers ──
  for (let i = 0; i < 60; i++) {
    const ang = (i / 60) * Math.PI * 2 - Math.PI / 2;
    const isHour = i % 5 === 0;
    
    if (isHour) {
      // Applied hour marker — flat rectangle with lume fill
      const markerH = R * 0.12;
      const markerW = R * 0.028;
      const outerR = R - R * 0.04;
      const midR = outerR - markerH / 2;
      
      const marker = makeAppliedMarker(markerW, markerH, c.hand, 2);
      marker.position.x = Math.cos(ang) * midR;
      marker.position.y = Math.sin(ang) * midR;
      marker.rotation.z = ang + Math.PI / 2;
      indicesGroup.add(marker);
      hourMarkers.push(marker);
      
      // Lume fill — slightly smaller, centered on marker
      const lumeH = markerH * 0.75;
      const lumeW = markerW * 0.6;
      const lume = makeAppliedMarker(lumeW, lumeH, c.lume, 2.5);
      lume.position.x = Math.cos(ang) * midR;
      lume.position.y = Math.sin(ang) * midR;
      lume.rotation.z = ang + Math.PI / 2;
      indicesGroup.add(lume);
      
      // Bloom copy
      const bloomLume = makeAppliedMarker(lumeW, lumeH, c.lume, 2.5);
      bloomLume.position.copy(lume.position);
      bloomLume.rotation.copy(lume.rotation);
      bloomGroup.add(bloomLume);
      bloomLumeMarkers.push({ main: lume, bloom: bloomLume });
    } else {
      // Minute tick — hair-thin line at rim
      const tickH = R * 0.03;
      const tickW = 1;
      const outerR = R - R * 0.04;
      const midR = outerR - tickH / 2;
      
      const tick = makeAppliedMarker(tickW, tickH, c.lume, 1);
      tick.material.transparent = true;
      tick.material.opacity = 0.3;
      tick.position.x = Math.cos(ang) * midR;
      tick.position.y = Math.sin(ang) * midR;
      tick.rotation.z = ang + Math.PI / 2;
      indicesGroup.add(tick);
      minuteMarkers.push(tick);
    }
  }
  
  // ── Arabic numerals ──
  for (let i = 0; i < 12; i++) {
    const ang = (i / 12) * Math.PI * 2 - Math.PI / 2;
    const r = R - R * 0.28;
    const fontSize = R * 0.12;
    const sprite = makeTextSprite(ARABIC[i], `700 ${fontSize}px Lateef,system-ui,sans-serif`, fontSize, c.text, 4);
    sprite.position.x = Math.cos(ang) * r;
    sprite.position.y = Math.sin(ang) * r;
    numeralsGroup.add(sprite);
    numeralSprites.push(sprite);
  }
  
  // ── Hands with shadows ──
  buildHands(c);
  
  // ── Center cap (simple, clean) ──
  capMeshes = [];
  const capR = R * 0.03;
  const capMain = makeCircle(capR, c.hand, 10);
  capGroup.add(capMain);
  capMeshes.push(capMain);
  // Small lume dot
  const capDot = makeCircle(capR * 0.5, c.lume, 11);
  capDot.material.transparent = true;
  capDot.material.opacity = 0.5;
  capGroup.add(capDot);
  capMeshes.push(capDot);
  
  // ── Qibla ──
  buildQibla(c);
  
  // ── Split-flap ──
  buildFlap();
  
  // ── Stars ──
  buildStars();
}

function buildHands(c) {
  const SHADOW_OFFSET = 3;
  const SHADOW_OPACITY = 0.2;
  
  // ── Hour hand ──
  hourHandGroup = new THREE.Group();
  hourHandGroup.position.z = 6;
  const hLen = R * 0.48, hWidth = R * 0.05, hTail = R * 0.06;
  hourHandMesh = makeLeafHand(hLen, hWidth, hTail, c.hand, 0);
  hourHandGroup.add(hourHandMesh);
  // Lume strip
  const hLumeW = hWidth * 0.35, hLumeH = hLen * 0.55;
  const hLumeGeo = new THREE.PlaneGeometry(hLumeW, hLumeH);
  hourLumeMesh = new THREE.Mesh(hLumeGeo, new THREE.MeshBasicMaterial({ color: hexToVec3(c.lume), transparent: true, opacity: 0.7 }));
  hourLumeMesh.position.y = hLen * 0.32;
  hourLumeMesh.position.z = 0.5;
  hourHandGroup.add(hourLumeMesh);
  handsGroup.add(hourHandGroup);
  
  // Hour shadow
  hourShadowGroup = new THREE.Group();
  hourShadowGroup.position.z = 5.5;
  const hShadow = makeLeafHand(hLen, hWidth * 1.1, hTail, '#000000', 0);
  hShadow.material.transparent = true;
  hShadow.material.opacity = SHADOW_OPACITY;
  hShadow.position.x = SHADOW_OFFSET;
  hShadow.position.y = -SHADOW_OFFSET;
  hourShadowGroup.add(hShadow);
  shadowGroup.add(hourShadowGroup);
  
  // Bloom lume
  const hBloomLume = new THREE.Mesh(hLumeGeo.clone(), new THREE.MeshBasicMaterial({ color: hexToVec3(c.lume) }));
  hBloomLume.position.y = hLen * 0.32;
  const hBloomGroup = new THREE.Group();
  hBloomGroup.position.z = 6;
  hBloomGroup.add(hBloomLume);
  bloomGroup.add(hBloomGroup);
  bloomHandLumes.push({ group: hBloomGroup, parent: hourHandGroup });
  
  // ── Minute hand ──
  minuteHandGroup = new THREE.Group();
  minuteHandGroup.position.z = 7;
  const mLen = R * 0.68, mWidth = R * 0.038, mTail = R * 0.08;
  minHandMesh = makeLeafHand(mLen, mWidth, mTail, c.hand, 0);
  minuteHandGroup.add(minHandMesh);
  // Lume strip
  const mLumeW = mWidth * 0.35, mLumeH = mLen * 0.55;
  const mLumeGeo = new THREE.PlaneGeometry(mLumeW, mLumeH);
  minLumeMesh = new THREE.Mesh(mLumeGeo, new THREE.MeshBasicMaterial({ color: hexToVec3(c.lume), transparent: true, opacity: 0.7 }));
  minLumeMesh.position.y = mLen * 0.32;
  minLumeMesh.position.z = 0.5;
  minuteHandGroup.add(minLumeMesh);
  handsGroup.add(minuteHandGroup);
  
  // Minute shadow
  minuteShadowGroup = new THREE.Group();
  minuteShadowGroup.position.z = 6.5;
  const mShadow = makeLeafHand(mLen, mWidth * 1.1, mTail, '#000000', 0);
  mShadow.material.transparent = true;
  mShadow.material.opacity = SHADOW_OPACITY;
  mShadow.position.x = SHADOW_OFFSET;
  mShadow.position.y = -SHADOW_OFFSET;
  minuteShadowGroup.add(mShadow);
  shadowGroup.add(minuteShadowGroup);
  
  // Bloom lume
  const mBloomLume = new THREE.Mesh(mLumeGeo.clone(), new THREE.MeshBasicMaterial({ color: hexToVec3(c.lume) }));
  mBloomLume.position.y = mLen * 0.32;
  const mBloomGroup = new THREE.Group();
  mBloomGroup.position.z = 7;
  mBloomGroup.add(mBloomLume);
  bloomGroup.add(mBloomGroup);
  bloomHandLumes.push({ group: mBloomGroup, parent: minuteHandGroup });
  
  // ── Second hand (thin, red/accent tip) ──
  secondHandGroup = new THREE.Group();
  secondHandGroup.position.z = 8;
  const sLen = R * 0.75, sTail = R * 0.18;
  const secShape = new THREE.Shape();
  secShape.moveTo(-0.5, -sTail);
  secShape.lineTo(-0.3, sLen);
  secShape.lineTo(0.3, sLen);
  secShape.lineTo(0.5, -sTail);
  secShape.closePath();
  secHandMesh = new THREE.Mesh(new THREE.ShapeGeometry(secShape), new THREE.MeshBasicMaterial({ color: hexToVec3(c.handStroke) }));
  secondHandGroup.add(secHandMesh);
  // Counterweight
  const cw = makeCircle(R * 0.015, c.handStroke, 0);
  cw.position.y = -sTail * 0.6;
  secondHandGroup.add(cw);
  handsGroup.add(secondHandGroup);
  
  // Second shadow
  secondShadowGroup = new THREE.Group();
  secondShadowGroup.position.z = 7.5;
  const sShadow = new THREE.Mesh(new THREE.ShapeGeometry(secShape.clone()), new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: SHADOW_OPACITY * 0.7 }));
  sShadow.position.x = SHADOW_OFFSET * 0.7;
  sShadow.position.y = -SHADOW_OFFSET * 0.7;
  secondShadowGroup.add(sShadow);
  shadowGroup.add(secondShadowGroup);
}

function buildQibla(c) {
  while (qiblaGroup.children.length) qiblaGroup.remove(qiblaGroup.children[0]);
  
  const outerR = R - R * 0.04;
  const markerH = R * 0.12;
  const midR = outerR - markerH / 2;
  const qr = R * 0.1;
  
  qiblaBg = makeCircle(qr, c.hand, 4);
  qiblaBg.position.y = midR;
  qiblaGroup.add(qiblaBg);
  
  // Thin border
  const border = makeRing(qr - 0.5, qr, c.shadow, 5);
  border.material.transparent = true;
  border.material.opacity = 0.25;
  border.position.y = midR;
  qiblaGroup.add(border);
  
  // Needle triangle
  const nL = qr * 0.85;
  const tipDist = nL * 0.55;
  const tailDist = nL * 0.45;
  const halfBase = nL * 0.35;
  const needleShape = new THREE.Shape();
  needleShape.moveTo(0, tipDist);
  needleShape.lineTo(halfBase, -tailDist);
  needleShape.lineTo(-halfBase, -tailDist);
  needleShape.closePath();
  qiblaNeedle = new THREE.Mesh(new THREE.ShapeGeometry(needleShape), new THREE.MeshBasicMaterial({ color: hexToVec3(c.bg) }));
  qiblaNeedle.position.y = midR;
  qiblaNeedle.position.z = 5;
  qiblaGroup.add(qiblaNeedle);
}

function buildFlap() {
  const cw = 512, ch = 192;
  flapCanvas = document.createElement('canvas');
  flapCanvas.width = cw;
  flapCanvas.height = ch;
  flapTexture = new THREE.CanvasTexture(flapCanvas);
  flapTexture.minFilter = THREE.LinearFilter;
  
  const geo = new THREE.PlaneGeometry(R * 0.65, R * 0.24);
  const mat = new THREE.MeshBasicMaterial({ map: flapTexture, transparent: true, depthTest: false });
  flapSprite = new THREE.Mesh(geo, mat);
  flapSprite.position.y = -R * 0.38;
  flapSprite.position.z = 9;
  flapGroup.add(flapSprite);
  
  const bloomFlap = new THREE.Mesh(geo.clone(), new THREE.MeshBasicMaterial({ map: flapTexture, transparent: true, depthTest: false }));
  bloomFlap.position.copy(flapSprite.position);
  bloomGroup.add(bloomFlap);
}

function buildStars() {
  while (starsGroup.children.length) starsGroup.remove(starsGroup.children[0]);
  STARS.forEach(s => {
    const geo = new THREE.CircleGeometry(s.r * 1.5, 16);
    const mat = new THREE.MeshBasicMaterial({ color: 0xfffff0, transparent: true, opacity: 0 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.x = (s.x - 0.5) * W;
    mesh.position.y = (0.5 - s.y) * H;
    mesh.position.z = -5;
    mesh.userData = s;
    starsGroup.add(mesh);
  });
}

// ── Update ──
let lastDialForTexture = '';
function updateColors() {
  const c = getColors();
  bgMat.color = hexToVec3(c.bg);
  
  // Regenerate dial texture when dial changes
  if (currentDial !== lastDialForTexture || modeBlend !== updateColors._lastBlend) {
    buildDialFace(c.bg);
    lastDialForTexture = currentDial;
    updateColors._lastBlend = modeBlend;
  }
  
  // Markers
  hourMarkers.forEach(m => m.material.color = hexToVec3(c.hand));
  bloomLumeMarkers.forEach(({ main, bloom }) => {
    main.material.color = hexToVec3(c.lume);
    bloom.material.color = hexToVec3(c.lume);
  });
  minuteMarkers.forEach(m => m.material.color = hexToVec3(c.lume));
  
  // Hands
  if (hourHandMesh) hourHandMesh.material.color = hexToVec3(c.hand);
  if (hourLumeMesh) hourLumeMesh.material.color = hexToVec3(c.lume);
  if (minHandMesh) minHandMesh.material.color = hexToVec3(c.hand);
  if (minLumeMesh) minLumeMesh.material.color = hexToVec3(c.lume);
  if (secHandMesh) secHandMesh.material.color = hexToVec3(c.handStroke);
  
  // Cap
  if (capMeshes[0]) capMeshes[0].material.color = hexToVec3(c.hand);
  if (capMeshes[1]) capMeshes[1].material.color = hexToVec3(c.lume);
  
  // Qibla
  if (qiblaBg) qiblaBg.material.color = hexToVec3(c.hand);
  if (qiblaNeedle) qiblaNeedle.material.color = hexToVec3(c.bg);
  
  // Bloom
  bloomPass.strength = 0.15 + modeBlend * 1.0;
  bloomPass2.strength = modeBlend * 1.8;
  
  // Stars
  starsGroup.children.forEach(mesh => {
    const s = mesh.userData;
    if (!s) return;
    const twinkle = Math.sin(Date.now() * s.speed + s.offset) * 0.3 + 0.7;
    mesh.material.opacity = modeBlend * s.bright * twinkle * 0.7;
  });
  
  document.querySelector('meta[name="theme-color"]').content = c.bg;
  return c;
}
updateColors._lastBlend = -1;

function updateHands() {
  const now = new Date();
  const h = now.getHours() % 12, m = now.getMinutes(), s = now.getSeconds(), ms = now.getMilliseconds();
  const sec = s + ms / 1000;
  const min = m + sec / 60;
  const hour = h + min / 60;
  
  const hourAng = -(hour / 12) * Math.PI * 2;
  const minAng = -(min / 60) * Math.PI * 2;
  const secAng = -(sec / 60) * Math.PI * 2;
  
  if (hourHandGroup) hourHandGroup.rotation.z = hourAng;
  if (minuteHandGroup) minuteHandGroup.rotation.z = minAng;
  if (secondHandGroup) secondHandGroup.rotation.z = secAng;
  
  // Shadows follow hands
  if (hourShadowGroup) hourShadowGroup.rotation.z = hourAng;
  if (minuteShadowGroup) minuteShadowGroup.rotation.z = minAng;
  if (secondShadowGroup) secondShadowGroup.rotation.z = secAng;
  
  // Bloom syncs
  bloomHandLumes.forEach(({ group, parent }) => { group.rotation.z = parent.rotation.z; });
}

function updateFlap(c) {
  if (!flapCanvas) return;
  const ctx = flapCanvas.getContext('2d');
  const cw = flapCanvas.width, ch = flapCanvas.height;
  ctx.clearRect(0, 0, cw, ch);
  
  const now = new Date();
  const h = now.getHours(), m = now.getMinutes();
  const nowMin = h * 60 + m + now.getSeconds() / 60;
  
  let label = 'UNTIL MAGHRIB';
  let mins = 0;
  
  if (PD) {
    const fajr = pM(PD.Fajr), mag = pM(PD.Maghrib);
    if (nowMin >= fajr && nowMin < mag) { mins = mag - nowMin; label = 'UNTIL IFTAR'; }
    else if (nowMin < fajr) { mins = fajr - nowMin; label = 'UNTIL FAJR'; }
    else { mins = 0; label = 'IFTAR'; }
  } else {
    mins = (18 * 60 + 15) - nowMin;
    if (mins < 0) mins = 0;
  }
  
  const hh = Math.floor(mins / 60), mm = Math.floor(mins % 60);
  const chars = [String(Math.floor(hh / 10)), String(hh % 10), ':', String(Math.floor(mm / 10)), String(mm % 10)];
  
  const nowMs = performance.now();
  while (flapPrevChars.length < chars.length) flapPrevChars.push('');
  while (flapCharAnims.length < chars.length) flapCharAnims.push({ start: 0, prev: '' });
  
  for (let i = 0; i < chars.length; i++) {
    if (chars[i] !== flapPrevChars[i]) {
      flapCharAnims[i] = { start: nowMs + i * FLAP_STAGGER, prev: flapPrevChars[i] || chars[i] };
    }
  }
  flapPrevChars = chars.slice();
  
  const digitW = cw * 0.17, colonW = cw * 0.06, cellH = ch * 0.65;
  const charWidths = chars.map(ch => ch === ':' ? colonW : digitW);
  const totalW = charWidths.reduce((a, w) => a + w, 0) + (chars.length - 1) * 4;
  let startX = (cw - totalW) / 2;
  const cellY = ch * 0.15;
  const fontSize = cellH * 0.7;
  const lumeCol = c.lume;
  
  let curX = startX;
  for (let i = 0; i < chars.length; i++) {
    const ch2 = chars[i];
    const charW = charWidths[i];
    const cellCx = curX + charW / 2;
    const anim = flapCharAnims[i];
    const elapsed = nowMs - (anim.start || 0);
    const t = Math.min(Math.max(elapsed / FLAP_DUR, 0), 1);
    
    if (ch2 === ':') {
      ctx.fillStyle = lumeCol;
      ctx.globalAlpha = 0.4;
      ctx.beginPath(); ctx.arc(cellCx, cellY + cellH * 0.3, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cellCx, cellY + cellH * 0.7, 3, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      curX += charW + 4;
      continue;
    }
    
    // Cell bg
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    roundRect(ctx, curX, cellY, charW, cellH, 4);
    ctx.fill();
    
    // Split line
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(curX, cellY + cellH / 2 - 0.5, charW, 1);
    
    // Digit
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `500 ${fontSize}px Inter,system-ui,sans-serif`;
    ctx.fillStyle = lumeCol;
    ctx.globalAlpha = 0.85;
    
    if (t < 1 && anim.prev) {
      const ease = t < 0.5 ? 2*t*t : 1-Math.pow(-2*t+2,2)/2;
      ctx.save();
      ctx.beginPath(); ctx.rect(curX, cellY + cellH/2, charW, cellH/2); ctx.clip();
      ctx.fillText(ch2, cellCx, cellY + cellH/2);
      ctx.restore();
      ctx.save();
      ctx.beginPath(); ctx.rect(curX, cellY, charW, cellH/2); ctx.clip();
      ctx.fillText(ease < 0.5 ? anim.prev : ch2, cellCx, cellY + cellH/2);
      ctx.restore();
    } else {
      ctx.fillText(ch2, cellCx, cellY + cellH/2);
    }
    ctx.globalAlpha = 1;
    curX += charW + 4;
  }
  
  // Label
  if (label) {
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `500 ${ch * 0.11}px Inter,system-ui,sans-serif`;
    ctx.fillStyle = lumeCol;
    ctx.globalAlpha = 0.6;
    ctx.fillText(label, cw/2, cellY + cellH + ch * 0.12);
    ctx.globalAlpha = 1;
  }
  
  flapTexture.needsUpdate = true;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r); ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
}

function updateFastingArc(c) {
  while (arcGroup.children.length) arcGroup.remove(arcGroup.children[0]);
  if (!PD) return;
  
  const fajr = pM(PD.Fajr), mag = pM(PD.Maghrib), now = nM();
  const startAng = ((fajr % 720) / 720) * Math.PI * 2 + Math.PI / 2;
  const sweepAng = ((mag - fajr) / 720) * Math.PI * 2;
  const endAng = startAng + sweepAng;
  const arcR = R + R * 0.12;
  const isLight = currentDial === 'white' || currentDial === 'cream';
  
  // Track
  const trackCurve = new THREE.EllipseCurve(0,0, arcR, arcR, startAng, endAng, false, 0);
  const track = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(trackCurve.getPoints(128)),
    new THREE.LineBasicMaterial({ color: isLight ? 0x000000 : 0xffffff, transparent: true, opacity: isLight ? 0.2 : 0.3 })
  );
  track.position.z = 1;
  arcGroup.add(track);
  
  // Progress
  if (now >= fajr && now <= mag) {
    const nowAng = startAng + ((now - fajr) / 720) * Math.PI * 2;
    const progCurve = new THREE.EllipseCurve(0,0, arcR, arcR, startAng, nowAng, false, 0);
    const prog = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(progCurve.getPoints(128)),
      new THREE.LineBasicMaterial({ color: isLight ? 0x000000 : 0xffffff, transparent: true, opacity: isLight ? 0.6 : 0.8 })
    );
    prog.position.z = 1;
    arcGroup.add(prog);
    
    // Red tip
    const tip = makeCircle(4, '#e53e3e', 2);
    tip.position.x = Math.cos(nowAng) * arcR;
    tip.position.y = Math.sin(nowAng) * arcR;
    arcGroup.add(tip);
  }
}

// ── Prayer times ──
async function fetchPrayer() {
  try {
    const r = await fetch('https://api.aladhan.com/v1/timings/' + Math.floor(Date.now()/1000));
    const j = await r.json();
    if (j.code === 200) { PD = j.data.timings; updateInfoPanel(); }
  } catch(e) { console.warn('Prayer fetch failed', e); }
}
fetchPrayer();

function updateInfoPanel() {
  if (!PD) return;
  const c = getColors();
  document.getElementById('hijri').textContent = `Fajr ${PD.Fajr} · Maghrib ${PD.Maghrib}`;
  document.getElementById('hijri').style.color = c.text;
  document.getElementById('greg').textContent = new Date().toLocaleDateString('en-US', { weekday:'long', year:'numeric', month:'long', day:'numeric' });
  document.getElementById('greg').style.color = c.text;
}

// ── Interactions ──
let infoVisible = false, infoTimer = null;
function showInfo() {
  document.getElementById('info').classList.add('visible');
  document.getElementById('dialBar').classList.add('visible');
  infoVisible = true;
  clearTimeout(infoTimer);
  infoTimer = setTimeout(() => {
    document.getElementById('info').classList.remove('visible');
    document.getElementById('dialBar').classList.remove('visible');
    infoVisible = false;
  }, 4000);
}

renderer.domElement.addEventListener('click', showInfo);
renderer.domElement.addEventListener('dblclick', () => { modeTarget = modeTarget > 0.5 ? 0 : 1; });

let touchStartX = 0;
renderer.domElement.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; });
renderer.domElement.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  if (Math.abs(dx) > 50) {
    const idx = DIAL_NAMES.indexOf(currentDial);
    currentDial = DIAL_NAMES[dx > 0 ? (idx-1+DIAL_NAMES.length)%DIAL_NAMES.length : (idx+1)%DIAL_NAMES.length];
    rebuildNumerals();
    updateDialDots();
  }
});

document.querySelectorAll('.dial-dot').forEach(dot => {
  dot.addEventListener('click', e => {
    e.stopPropagation();
    currentDial = dot.dataset.dial;
    rebuildNumerals();
    updateDialDots();
  });
});

function updateDialDots() {
  document.querySelectorAll('.dial-dot').forEach(d => d.classList.toggle('active', d.dataset.dial === currentDial));
}

function rebuildNumerals() {
  while (numeralsGroup.children.length) numeralsGroup.remove(numeralsGroup.children[0]);
  numeralSprites = [];
  const c = getColors();
  for (let i = 0; i < 12; i++) {
    const ang = (i / 12) * Math.PI * 2 - Math.PI / 2;
    const r = R - R * 0.28;
    const fontSize = R * 0.12;
    const sprite = makeTextSprite(ARABIC[i], `700 ${fontSize}px Lateef,system-ui,sans-serif`, fontSize, c.text, 4);
    sprite.position.x = Math.cos(ang) * r;
    sprite.position.y = Math.sin(ang) * r;
    numeralsGroup.add(sprite);
    numeralSprites.push(sprite);
  }
}

// ── Resize ──
function onResize() {
  W = window.innerWidth;
  H = window.innerHeight;
  R = Math.min(W, H) * 0.42;
  
  renderer.setSize(W, H);
  cam.left = -W/2; cam.right = W/2; cam.top = H/2; cam.bottom = -H/2;
  cam.updateProjectionMatrix();
  
  composer.setSize(W, H);
  bloomComposer.setSize(W, H);
  bloomPass.resolution.set(W, H);
  bloomPass2.resolution.set(W, H);
  
  bgMesh.scale.set(W*2/bgGeo.parameters.width, H*2/bgGeo.parameters.height, 1);
  bloomBgMesh.scale.set(W*2/bloomBgGeo.parameters.width, H*2/bloomBgGeo.parameters.height, 1);
  
  buildClock();
}
window.addEventListener('resize', onResize);

// ── Night mode blend ──
function updateMode() {
  if (Math.abs(modeBlend - modeTarget) > 0.001) {
    modeBlend += (modeTarget - modeBlend) * 0.05;
  } else {
    modeBlend = modeTarget;
  }
}

// ── Render ──
function animate() {
  requestAnimationFrame(animate);
  
  updateMode();
  const c = updateColors();
  updateHands();
  updateFlap(c);
  updateFastingArc(c);
  
  renderer.autoClear = false;
  renderer.clear();
  composer.render();
}

buildClock();
animate();
showInfo();

</script>
</body>
</html>
